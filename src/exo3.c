//=============================================
//      pass.c
//=============================================

#include "dsk6416.h"
#include "dsk6416_aic23.h"
#include "dsk6416_dip.h"
#include "dsk6416_led.h"

#include "pass.h"
#define FILTER_ORDER 80
short filterStatus = 0;
short x[FILTER_ORDER +1];
short yn;

//Sampling frequency
uint32_t fs=DSK6416_AIC23_FREQ_16KHZ;

short coef[81]={11, 12, 12, 11, 10, 7, 2, -4, -11, -17, -21, -20, -14, -1, 18, 40, 61, 74, 71, 44, -15, -111, -245, -411, -600, -795, -975, -1116, -1192, -1184, -1074, -856, -533, -120, 355, 860, 1352, 1790, 2135, 2356, 2432, 2356, 2135, 1790, 1352, 860, 355, -120, -533, -856, -1074, -1184, -1192, -1116, -975, -795, -600, -411, -245, -111, -15, 44, 71, 74, 61, 40, 18, -1, -14, -20, -21, -17, -11, -4, 2, 7, 10, 11, 12, 12, 11};
short coef_pb[81] = {1, 4, 7, 9, 8, 4, -5, -15, -25, -30, -24, -6, 23, 57, 83, 88, 60, -1, -84, -166, -216, -203, -113, 46, 239, 407, 481, 409, 171, -201, -621, -960, -1076, -848, -217, 792, 2063, 3406, 4592, 5406, 5696, 5406, 4592, 3406, 2063, 792, -217, -848, -1076, -960, -621, -201, 171, 409, 481, 407, 239, 46, -113, -203, -216, -166, -84, -1, 60, 88, 83, 57, 23, -6, -24, -30, -25, -15, -5, 4, 8, 9, 7, 4, 1};
short coef_pbnd[81] = {-1, -6, -11, -13, -9, -3, 0, -6, -24, -48, -65, -56, -14, 48, 102, 114, 74, 12, -14, 52, 216, 416, 537, 474, 209, -155, -432, -459, -217, 119, 234, -154, -1093, -2297, -3205, -3223, -2027, 216, 2847, 4955, 5760, 4955, 2847, 216, -2027, -3223, -3205, -2297, -1093, -154, 234, 119, -217, -459, -432, -155, 209, 474, 537, 416, 216, 52, -14, 12, 74, 114, 102, 48, -14, -56, -65, -48, -24, -6, 0, -3, -9, -13, -11, -6, -1};
short coef_ph[81] = {1, 4, 7, 9, 10, 8, 2, -7, -18, -30, -39, -39, -27, -2, 36, 78, 115, 132, 119, 67, -21, -134, -246, -328, -348, -281, -120, 123, 408, 673, 846, 853, 635, 165, -544, -1435, -2415, -3363, -4155, -4680, 27904, -4680, -4155, -3363, -2415, -1435, -544, 165, 635, 853, 846, 673, 408, 123, -120, -281, -348, -328, -246, -134, -21, 67, 119, 132, 115, 78, 36, -2, -27, -39, -39, -30, -18, -7, 2, 8, 10, 9, 7, 4, 1};


void apply_filter(short input)
{
    short *h;
    //sélecteur de filtre
    switch (filterStatus)
    {
        case 0:
            h = coef_pb;
            break;
        case 1:
            h = coef_ph;
            break;
        case 2:
            h = coef_pbnd;
            break;
        default :
            yn = input;
            break;
        }
    int i;
    // décalage des échantillons d'entrée
    for (i = 0; i < FILTER_ORDER ;i++)
    {
        x[i] = x[i+1];
    }
    x[80] = input;
    yn = 0;

    // calcul de la sortie du filtre (résultat envoyé à l'oscillo)

    for (i = 0; i <= FILTER_ORDER; i++)
    {
        yn += (h[i] * x[i]) >> 15;
    }


}

//New ADC sample interrupt
interrupt void c_int11()
{
    short input = input_left_sample();
    apply_filter(input);
    output_left_sample(yn);
}

void main()
{
    DSK6416_DIP_init();
    DSK6416_LED_init();


    //init codec,DSK, MCBSP
         comm_intr();   // or without interrupt: comm_poll();

        while(1)
        {
           //Dip switchs and leds example
            if (DSK6416_DIP_get(2) == 1)
               DSK6416_LED_off(1);
            else
               DSK6416_LED_on(1);
        }
}                                               //end of main


